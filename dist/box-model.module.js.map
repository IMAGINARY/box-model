{"version":3,"file":"box-model.module.js","sources":["../src/ode.ts","../src/util.ts","../src/box-model.ts"],"sourcesContent":["export function euler(\n  y: ReadonlyArray<number>,\n  x: number,\n  h: number,\n  derivatives: (y: ReadonlyArray<number>, x: number) => number[]\n): number[] {\n  const dydx = derivatives(y, x);\n  return y.map((yi, i) => yi + h * dydx[i]);\n}\n\nexport function rk4(\n  y: ReadonlyArray<number>,\n  x: number,\n  h: number,\n  derivatives: (y: ReadonlyArray<number>, x: number) => number[]\n): number[] {\n  const n: number = y.length;\n\n  const dydx = derivatives(y, x);\n  const yTemp: number[] = new Array(n) as number[];\n\n  const h2 = h / 2.0;\n  const h6 = h / 6.0;\n  const xhh = x + h2;\n\n  for (let i = 0; i < n; i += 1) yTemp[i] = y[i] + h2 * dydx[i];\n  let dydxTemp = derivatives(yTemp, xhh);\n\n  for (let i = 0; i < n; i += 1) yTemp[i] = y[i] + h2 * dydxTemp[i];\n  const dydxM = derivatives(yTemp, xhh);\n\n  for (let i = 0; i < n; i += 1) {\n    yTemp[i] = y[i] + h * dydxM[i];\n    dydxM[i] += dydxTemp[i];\n  }\n  dydxTemp = derivatives(yTemp, x + h);\n\n  return y.map((_, i) => y[i] + h6 * (dydx[i] + dydxTemp[i] + 2.0 * dydxM[i]));\n}\n","export function sum(arr: Array<number>): number {\n  return arr.reduce((acc, cur) => acc + cur, 0);\n}\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst hasOwnPropertyFunc = Object.prototype.hasOwnProperty;\nexport function hasOwnProperty(\n  o: Record<string, unknown>,\n  key: string\n): boolean {\n  return hasOwnPropertyFunc.call(o, key);\n}\n","import {\n  BoxModel,\n  BoxModelOptions,\n  LookupFunction,\n  Record,\n  IVPIntegrator,\n} from './types';\n\nimport { rk4 } from './ode';\n\nimport { sum, hasOwnProperty } from './util';\n\ninterface LookupFunctionWithData extends LookupFunction {\n  data: (number | boolean)[];\n}\n\ntype FlowGetter = (\n  y: ReadonlyArray<number>,\n  x: number\n) => ReadonlyArray<number>;\n\nfunction throwLookupError(tableName: string, id: string) {\n  throw new Error(\n    `Value of unknown ${tableName} requested: ${id}. Check your box model definition.`\n  );\n}\n\ntype ConvergenceCriterion = (\n  r: Record,\n  rPrevious: Record,\n  i: number,\n  bme: BoxModelEngine\n) => boolean;\n\nexport default class BoxModelEngine {\n  public model: BoxModel;\n\n  public integrator: IVPIntegrator;\n\n  constructor(model: BoxModel, options: BoxModelOptions = { integrator: rk4 }) {\n    this.model = model;\n    this.integrator = options.integrator;\n  }\n\n  public static createIdToIdxMap(arr: ReadonlyArray<{ readonly id: string }>): {\n    [key: string]: number;\n  } {\n    return arr.reduce((acc: { [key: string]: number }, { id }, idx) => {\n      acc[id] = idx;\n      return acc;\n    }, {});\n  }\n\n  public createGraphEvaluator(): (\n    stocks: ReadonlyArray<number>,\n    t: number\n  ) => Record {\n    const { stocks: ms, flows: mf, variables: mv, parameters: mp } = this.model;\n\n    const stockIdToIdx = BoxModelEngine.createIdToIdxMap(ms);\n    const flowIdToIdx = BoxModelEngine.createIdToIdxMap(mf);\n    const variableIdToIdx = BoxModelEngine.createIdToIdxMap(mv);\n    const parameterIdToIdx = BoxModelEngine.createIdToIdxMap(mp);\n\n    let r: Record = {\n      t: 0,\n      stocks: new Array(ms.length) as number[],\n      flows: new Array(mf.length) as number[],\n      variables: new Array(mv.length) as number[],\n      parameters: new Array(mp.length) as number[],\n    };\n\n    const flowInitializing = new Array(mf.length) as boolean[];\n    const variableInitializing = new Array(mv.length) as boolean[];\n\n    const s: LookupFunction = (id) => {\n      if (!hasOwnProperty(stockIdToIdx, id)) throwLookupError('stock', id);\n      return r.stocks[stockIdToIdx[id]];\n    };\n\n    const p: LookupFunction = (id) => {\n      if (!hasOwnProperty(parameterIdToIdx, id))\n        throwLookupError('parameter', id);\n      return r.parameters[parameterIdToIdx[id]];\n    };\n\n    let v: LookupFunction;\n\n    const f: LookupFunction = (id) => {\n      if (!hasOwnProperty(flowIdToIdx, id)) throwLookupError('variable', id);\n      const idx = flowIdToIdx[id];\n      if (r.flows[idx] === undefined) {\n        // not initialized yet\n        if (flowInitializing[idx]) {\n          throw new Error(`Evaluation cycle detected starting at: flow ${id}`);\n        } else {\n          flowInitializing[idx] = true; // guard the element for cycle detection\n          r.flows[idx] = mf[idx].formula({ s, f, v, p, t: r.t });\n        }\n      }\n      return r.flows[idx];\n    };\n\n    v = (id) => {\n      if (!hasOwnProperty(variableIdToIdx, id))\n        throwLookupError('variable', id);\n      const idx = variableIdToIdx[id];\n      if (r.variables[idx] === undefined) {\n        // not initialized yet\n        if (variableInitializing[idx]) {\n          throw new Error(\n            `Evaluation cycle detected starting at: variable ${id}`\n          );\n        } else {\n          variableInitializing[idx] = true; // guard the element for cycle detection\n          r.variables[idx] = mv[idx].formula({ s, f, v, p, t: r.t });\n        }\n      }\n      return r.variables[idx];\n    };\n\n    const evaluator = (stocks: ReadonlyArray<number>, t: number): Record => {\n      r = {\n        t,\n        stocks: stocks as number[],\n        flows: new Array(mf.length) as number[],\n        variables: new Array(mv.length) as number[],\n        parameters: mp.map(({ value }) => value),\n      };\n\n      flowInitializing.fill(false);\n      variableInitializing.fill(false);\n\n      this.model.variables.forEach(({ id }) => v(id));\n      this.model.flows.forEach(({ id }) => f(id));\n\n      return r;\n    };\n\n    return evaluator;\n  }\n\n  public evaluateGraph(stocks: ReadonlyArray<number>, t: number): Record {\n    return this.createGraphEvaluator()(stocks, t);\n  }\n\n  public step(stocksAtT: ReadonlyArray<number>, t: number, h: number): number[];\n  public step(\n    stocksAtT: ReadonlyArray<number>,\n    flowsAtT: ReadonlyArray<number>,\n    t: number,\n    h: number\n  ): number[];\n  public step(\n    stocksAtT: ReadonlyArray<number>,\n    tOrFlowsAtT: ReadonlyArray<number> | number,\n    tOrH: number,\n    h?: number\n  ): number[] {\n    if (typeof tOrFlowsAtT === 'number')\n      return this.step3(stocksAtT, tOrFlowsAtT, tOrH);\n    if (typeof h !== 'undefined')\n      return this.step4(stocksAtT, tOrFlowsAtT, tOrH, h);\n    throw new TypeError();\n  }\n\n  private step3(\n    stocksAtT: ReadonlyArray<number>,\n    t: number,\n    h: number\n  ): number[] {\n    const evaluateGraph = this.createGraphEvaluator();\n    const getFlows: FlowGetter = (y, x) => evaluateGraph(y, x).flows;\n    return this.stepImpl(stocksAtT, getFlows, t, h);\n  }\n\n  private step4(\n    stocksAtT: ReadonlyArray<number>,\n    flowsAtT: ReadonlyArray<number>,\n    t: number,\n    h: number\n  ): number[] {\n    const evaluateGraph = this.createGraphEvaluator();\n    const getFlows: FlowGetter = (y, x) =>\n      x === t ? flowsAtT : evaluateGraph(y, x).flows;\n    return this.stepImpl(stocksAtT, getFlows, t, h);\n  }\n\n  protected stepImpl(\n    stocksAtT: ReadonlyArray<number>,\n    getFlows: FlowGetter,\n    t: number,\n    h: number\n  ): number[] {\n    const flowIdToIdx = BoxModelEngine.createIdToIdxMap(this.model.flows);\n\n    const derivatives = (y: ReadonlyArray<number>, x: number): number[] => {\n      const flows = getFlows(y, x);\n\n      const f: LookupFunction = (id): number => flows[flowIdToIdx[id]];\n      const addFlows = (flowIds: ReadonlyArray<string>) => sum(flowIds.map(f));\n\n      return this.model.stocks.map((s) => addFlows(s.in) - addFlows(s.out));\n    };\n\n    return this.integrator(stocksAtT, t, h, derivatives);\n  }\n\n  public stepExt(\n    stocksAtT: ReadonlyArray<number>,\n    t: number,\n    h: number\n  ): Record;\n  public stepExt(\n    stocksAtT: ReadonlyArray<number>,\n    flowsAtT: ReadonlyArray<number>,\n    t: number,\n    h: number\n  ): Record;\n  public stepExt(\n    stocksAtT: ReadonlyArray<number>,\n    tOrFlowsAtT: ReadonlyArray<number> | number,\n    tOrH: number,\n    h?: number\n  ): Record {\n    if (typeof tOrFlowsAtT === 'number')\n      return this.stepExt3(stocksAtT, tOrFlowsAtT, tOrH);\n    if (typeof h !== 'undefined')\n      return this.stepExt4(stocksAtT, tOrFlowsAtT, tOrH, h);\n    throw new TypeError();\n  }\n\n  private stepExt3(\n    stocksAtT: ReadonlyArray<number>,\n    t: number,\n    h: number\n  ): Record {\n    const stocks = this.step(stocksAtT, t, h);\n    return this.evaluateGraph(stocks, t + h);\n  }\n\n  private stepExt4(\n    stocksAtT: ReadonlyArray<number>,\n    flowsAtT: ReadonlyArray<number>,\n    t: number,\n    h: number\n  ): Record {\n    const stocks = this.step(stocksAtT, flowsAtT, t, h);\n    return this.evaluateGraph(stocks, t + h);\n  }\n\n  public converge(\n    stocksAtT: ReadonlyArray<number>,\n    t: number,\n    h: number,\n    criteria: ConvergenceCriterion\n  ): number[] {\n    return this.convergeExt(stocksAtT, t, h, criteria).stocks;\n  }\n\n  public convergeExt(\n    stocksAtT: ReadonlyArray<number>,\n    t: number,\n    h: number,\n    criterion: ConvergenceCriterion\n  ): Record {\n    const evaluateGraph = this.createGraphEvaluator();\n    let lastRecord = evaluateGraph(stocksAtT, t);\n    const getFlows: FlowGetter = (y, x) =>\n      x === lastRecord.t ? lastRecord.flows : evaluateGraph(y, x).flows;\n    for (let i = 0, stop = false; !stop; i += 1) {\n      const stocks = this.stepImpl(\n        lastRecord.stocks,\n        getFlows,\n        lastRecord.t,\n        h\n      );\n      const record = evaluateGraph(stocks, t + i * h);\n      stop = criterion(record, lastRecord, i, this);\n      lastRecord = record;\n    }\n    return lastRecord;\n  }\n}\n\nexport { BoxModelEngine, ConvergenceCriterion };\n"],"names":["euler","y","x","h","derivatives","dydx","map","yi","i","rk4","n","length","yTemp","Array","h2","h6","xhh","dydxTemp","dydxM","_","hasOwnPropertyFunc","Object","prototype","hasOwnProperty","o","key","call","throwLookupError","tableName","id","Error","BoxModelEngine","model","options","integrator","this","createIdToIdxMap","arr","reduce","acc","idx","_ref","createGraphEvaluator","v","_this","_this$model","ms","stocks","mf","flows","mv","variables","mp","parameters","stockIdToIdx","flowIdToIdx","variableIdToIdx","parameterIdToIdx","r","t","flowInitializing","variableInitializing","s","p","f","undefined","formula","_ref2","value","fill","forEach","evaluateGraph","step","stocksAtT","tOrFlowsAtT","tOrH","step3","step4","TypeError","stepImpl","flowsAtT","getFlows","_this2","addFlows","flowIds","cur","out","stepExt","stepExt3","stepExt4","converge","criteria","convergeExt","criterion","lastRecord","stop","record"],"mappings":"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"}