{"version":3,"file":"box-model.modern.js","sources":["../src/ode.ts","../src/box-model.ts"],"sourcesContent":["export type IVPIntegrator = (\n  y: number[],\n  x: number,\n  h: number,\n  derivatives: (y: number[], x: number) => number[]\n) => number[];\n\nexport function euler(\n  y: number[],\n  x: number,\n  h: number,\n  derivatives: (y: number[], x: number) => number[]\n): number[] {\n  const dydx = derivatives(y, x);\n  return y.map((yi, i) => yi + h * dydx[i]);\n}\n\nexport function rk4(\n  y: number[],\n  x: number,\n  h: number,\n  derivatives: (y: number[], x: number) => number[]\n): number[] {\n  const n: number = y.length;\n\n  const dydx = derivatives(y, x);\n  const yTemp: number[] = new Array(n) as number[];\n\n  const h2 = h / 2.0;\n  const h6 = h / 6.0;\n  const xhh = x + h2;\n\n  for (let i = 0; i < n; i += 1) yTemp[i] = y[i] + h2 * dydx[i];\n  let dydxTemp = derivatives(yTemp, xhh);\n\n  for (let i = 0; i < n; i += 1) yTemp[i] = y[i] + h2 * dydxTemp[i];\n  const dydxM = derivatives(yTemp, xhh);\n\n  for (let i = 0; i < n; i += 1) {\n    yTemp[i] = y[i] + h * dydxM[i];\n    dydxM[i] += dydxTemp[i];\n  }\n  dydxTemp = derivatives(yTemp, x + h);\n\n  return y.map((_, i) => y[i] + h6 * (dydx[i] + dydxTemp[i] + 2.0 * dydxM[i]));\n}\n","import { IVPIntegrator, euler, rk4 } from './ode';\n\nexport { IVPIntegrator, euler, rk4 };\n\ntype LookupFunction = (id: string) => number;\n\ninterface LookupFunctionWithData extends LookupFunction {\n  data: number[];\n}\n\nexport type Formula = (\n  s: LookupFunction,\n  f: LookupFunction,\n  v: LookupFunction,\n  c: LookupFunction,\n  t: number\n) => number;\n\nexport interface Stock {\n  readonly id: string;\n  readonly in: ReadonlyArray<string>;\n  readonly out: ReadonlyArray<string>;\n}\n\nexport interface Flow {\n  readonly id: string;\n  readonly formula: Formula;\n}\n\nexport interface Variable {\n  readonly id: string;\n  readonly formula: Formula;\n}\n\nexport interface Parameter {\n  readonly id: string;\n  value: number;\n}\n\nexport interface Record {\n  stocks: number[];\n  flows: number[];\n  variables: number[];\n  parameters: number[];\n  t: number;\n}\n\nfunction duplicates<Type>(arr: Type[]): Type[] {\n  return arr.reduce((acc, cur, curIdx, a) => {\n    if (a.lastIndexOf(cur) !== curIdx) {\n      a.push(cur);\n    }\n    return acc;\n  }, [] as Type[]);\n}\n\nfunction sum(arr: Array<number>) {\n  return arr.reduce((acc, cur) => acc + cur, 0);\n}\n\nexport default class BoxModel {\n  public readonly stocks: ReadonlyArray<Stock>;\n\n  public readonly flows: ReadonlyArray<Flow>;\n\n  public readonly variables: ReadonlyArray<Variable>;\n\n  public readonly parameters: ReadonlyArray<Parameter>;\n\n  public integrator: IVPIntegrator;\n\n  protected idToIdx: { [key: string]: number };\n\n  constructor(\n    {\n      stocks,\n      flows,\n      variables,\n      parameters,\n    }: {\n      stocks: Stock[];\n      flows: Flow[];\n      variables: Variable[];\n      parameters: Parameter[];\n    },\n    integrator: IVPIntegrator = rk4\n  ) {\n    this.stocks = stocks;\n    this.flows = flows;\n    this.variables = variables;\n    this.parameters = parameters;\n    this.integrator = integrator;\n\n    this.ensureUniqueIds();\n\n    this.idToIdx = {\n      ...BoxModel.createIdToIdxMap(stocks),\n      ...BoxModel.createIdToIdxMap(variables),\n      ...BoxModel.createIdToIdxMap(parameters),\n      ...BoxModel.createIdToIdxMap(flows),\n    };\n  }\n\n  protected ensureUniqueIds(): void {\n    const ids = ([] as Array<{ id: string }>)\n      .concat(this.stocks, this.variables, this.parameters, this.flows)\n      .map((item) => item.id);\n    const duplicateIds = duplicates(ids);\n    if (duplicateIds.length > 0) {\n      throw new Error(`Duplicate ids found: ${JSON.stringify(duplicateIds)}`);\n    }\n  }\n\n  static createIdToIdxMap(\n    arr: Array<{ id: string }>\n  ): { [key: string]: number } {\n    return arr.reduce(\n      (acc, { id }, idx) => Object.assign(acc, { [id]: idx }),\n      {}\n    );\n  }\n\n  public evaluateGraph(stocks: number[], t: number): Record {\n    const s: LookupFunction = (id) => stocks[this.idToIdx[id]];\n\n    const parameters = this.parameters.map(({ value }) => value);\n    const p: LookupFunction = (id) => parameters[this.idToIdx[id]];\n\n    let f: LookupFunctionWithData;\n    let v: LookupFunctionWithData;\n\n    const buildEvaluator = (\n      items: ReadonlyArray<Flow> | ReadonlyArray<Variable>\n    ): LookupFunctionWithData => {\n      const data = new Array(items.length) as number[];\n      const evaluator = (id: string) => {\n        const idx = this.idToIdx[id];\n        if (data[idx] === null) {\n          throw new Error(`Evaluation cycle detected starting at: ${id}`);\n        }\n\n        if (typeof data[idx] === 'undefined') {\n          data[idx] = null; // guard the element for cycle detection\n          data[idx] = items[idx].formula(s, f, v, p, t);\n        }\n        return data[idx];\n      };\n      evaluator.data = data;\n      return evaluator;\n    };\n\n    v = buildEvaluator(this.variables);\n    const variables = v.data;\n\n    f = buildEvaluator(this.flows);\n    const flows = f.data;\n\n    this.variables.forEach(({ id }) => v(id));\n    this.flows.forEach(({ id }) => f(id));\n\n    return { stocks, flows, variables, parameters, t };\n  }\n\n  public step(stocksAtT: number[], t: number, h: number): number[];\n  public step(\n    stocksAtT: number[],\n    flowsAtT: number[],\n    t: number,\n    h: number\n  ): number[];\n  public step(\n    stocksAtT: number[],\n    tOrFlowsAtT: number[] | number,\n    tOrH: number,\n    h?: number\n  ): number[] {\n    return typeof tOrFlowsAtT === 'number'\n      ? this.step3(stocksAtT, tOrFlowsAtT, tOrH)\n      : this.step4(stocksAtT, tOrFlowsAtT, tOrH, h);\n  }\n\n  private step3(stocksAtT: number[], t: number, h: number): number[] {\n    const getFlows = (y, x) => this.evaluateGraph(y, x).flows;\n    return this.stepImpl(stocksAtT, getFlows, t, h);\n  }\n\n  private step4(\n    stocksAtT: number[],\n    flowsAtT: number[],\n    t: number,\n    h: number\n  ): number[] {\n    const getFlows = (y, x) =>\n      x === t ? flowsAtT : this.evaluateGraph(y, x).flows;\n    return this.stepImpl(stocksAtT, getFlows, t, h);\n  }\n\n  protected stepImpl(\n    stocksAtT: number[],\n    getFlows: (y: number[], x: number) => number[],\n    t: number,\n    h: number\n  ): number[] {\n    const derivatives = (y: number[], x: number): number[] => {\n      const flows = getFlows(y, x);\n\n      const f: LookupFunction = (id): number => flows[this.idToIdx[id]];\n      const addFlows = (flowIds: ReadonlyArray<string>) => sum(flowIds.map(f));\n\n      return this.stocks.map((s) => addFlows(s.in) - addFlows(s.out));\n    };\n\n    return this.integrator(stocksAtT, t, h, derivatives);\n  }\n\n  public stepExt(stocksAtT: number[], t: number, h: number): Record;\n  public stepExt(\n    stocksAtT: number[],\n    flowsAtT: number[],\n    t: number,\n    h: number\n  ): Record;\n  public stepExt(\n    stocksAtT: number[],\n    tOrFlowsAtT: number[] | number,\n    tOrH: number,\n    h?: number\n  ): Record {\n    return typeof tOrFlowsAtT === 'number'\n      ? this.stepExt3(stocksAtT, tOrFlowsAtT, tOrH)\n      : this.stepExt4(stocksAtT, tOrFlowsAtT, tOrH, h);\n  }\n\n  private stepExt3(stocksAtT: number[], t: number, h: number): Record {\n    const stocks = this.step(stocksAtT, t, h);\n    return { stocks, ...this.evaluateGraph(stocks, t + h) };\n  }\n\n  private stepExt4(\n    stocksAtT: number[],\n    flowsAtT: number[],\n    t: number,\n    h: number\n  ): Record {\n    const stocks = this.step(stocksAtT, flowsAtT, t, h);\n    return { stocks, ...this.evaluateGraph(stocks, t + h) };\n  }\n}\n\nexport { BoxModel };\n"],"names":["euler","y","x","h","derivatives","dydx","map","yi","i","rk4","n","length","yTemp","Array","h2","h6","xhh","dydxTemp","dydxM","_","BoxModel","constructor","stocks","flows","variables","parameters","integrator","this","ensureUniqueIds","idToIdx","createIdToIdxMap","duplicateIds","concat","item","id","reduce","acc","cur","curIdx","a","lastIndexOf","push","Error","JSON","stringify","[object Object]","arr","idx","Object","assign","evaluateGraph","t","s","value","p","f","v","buildEvaluator","items","data","evaluator","formula","forEach","step","stocksAtT","tOrFlowsAtT","tOrH","step3","step4","stepImpl","flowsAtT","getFlows","addFlows","flowIds","in","out","stepExt","stepExt3","stepExt4"],"mappings":"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"}