function t(){return(t=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var e=arguments[s];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}return t}).apply(this,arguments)}function s(t,s,e,r){const a=r(t,s);return t.map((t,s)=>t+e*a[s])}function e(t,s,e,r){const a=t.length,n=r(t,s),o=new Array(a),i=e/2,c=e/6,h=s+i;for(let s=0;s<a;s+=1)o[s]=t[s]+i*n[s];let l=r(o,h);for(let s=0;s<a;s+=1)o[s]=t[s]+i*l[s];const p=r(o,h);for(let s=0;s<a;s+=1)o[s]=t[s]+e*p[s],p[s]+=l[s];return l=r(o,s+e),t.map((s,e)=>t[e]+c*(n[e]+l[e]+2*p[e]))}class r{constructor({stocks:s,flows:a,variables:n,constants:o},i=e){this.stocks=s,this.flows=a,this.variables=n,this.constants=o,this.integrator=i,this.ensureUniqueIds(),this.idToIdx=t({},r.createIdToIdxMap(s),r.createIdToIdxMap(n),r.createIdToIdxMap(o),r.createIdToIdxMap(a))}ensureUniqueIds(){const t=[].concat(this.stocks,this.variables,this.constants,this.flows).map(t=>t.id).reduce((t,s,e,r)=>(r.lastIndexOf(s)!==e&&r.push(s),t),[]);if(t.length>0)throw new Error(`Duplicate ids found: ${JSON.stringify(t)}`)}static createIdToIdxMap(t){return t.reduce((t,{id:s},e)=>Object.assign(t,{[s]:e}),{})}evaluateGraph(t,s){const e=s=>t[this.idToIdx[s]],r=this.constants.map(({value:t})=>t),a=t=>r[this.idToIdx[t]];let n,o;const i=t=>{const r=new Array(t.length),i=i=>{const c=this.idToIdx[i];if(null===r[c])throw new Error(`Evaluation cycle detected starting at: ${i}`);return void 0===r[c]&&(r[c]=null,r[c]=t[c].formula(e,n,o,a,s)),r[c]};return i.data=r,i};o=i(this.variables);const c=o.data;n=i(this.flows);const h=n.data;return this.variables.forEach(({id:t})=>o(t)),this.flows.forEach(({id:t})=>n(t)),{stocks:t,flows:h,variables:c,constants:r,t:s}}step(t,s,e,r){return"number"==typeof s?this.step3(t,s,e):this.step4(t,s,e,r)}step3(t,s,e){return this.stepImpl(t,(t,s)=>this.evaluateGraph(t,s).flows,s,e)}step4(t,s,e,r){return this.stepImpl(t,(t,r)=>r===e?s:this.evaluateGraph(t,r).flows,e,r)}stepImpl(t,s,e,r){return this.integrator(t,e,r,(t,e)=>{const r=s(t,e),a=t=>r[this.idToIdx[t]],n=t=>t.map(a).reduce((t,s)=>t+s,0);return this.stocks.map(t=>n(t.in)-n(t.out))})}stepExt(t,s,e,r){return"number"==typeof s?this.stepExt3(t,s,e):this.stepExt4(t,s,e,r)}stepExt3(s,e,r){const a=this.step(s,e,r);return t({stocks:a},this.evaluateGraph(a,e+r))}stepExt4(s,e,r,a){const n=this.step(s,e,r,a);return t({stocks:n},this.evaluateGraph(n,r+a))}}export{r as BoxModel,s as euler,e as rk4};
//# sourceMappingURL=box-model.modern.js.map
