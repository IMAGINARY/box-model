function t(){return(t=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var e=arguments[s];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}return t}).apply(this,arguments)}function s(t,s,e,r){const a=r(t,s);return t.map((s,r)=>t[r]+e*a[r])}function e(t,s,e,r){const a=t.length,o=r(t,s),n=Array(a),i=e/2,h=e/6,c=s+i;for(let s=0;s<a;s+=1)n[s]=t[s]+i*o[s];let l=r(n,c);for(let s=0;s<a;s+=1)n[s]=t[s]+i*l[s];const u=r(n,c);for(let s=0;s<a;s+=1)n[s]=t[s]+e*u[s],u[s]+=l[s];return l=r(n,s+e),t.map((s,e)=>t[e]+h*(o[e]+l[e]+2*u[e]))}class r{constructor({stocks:s,flows:a,variables:o,constants:n},i=e){this.stocks=s,this.flows=a,this.variables=o,this.constants=n,this.integrator=i,this.ensureUniqueIds(),this.idToIdx=t({},r.createIdToIdxMap(s),r.createIdToIdxMap(o),r.createIdToIdxMap(n),r.createIdToIdxMap(a))}ensureUniqueIds(){const t=[].concat(this.stocks,this.variables,this.constants,this.flows).map(t=>t.id).reduce((t,s,e,r)=>(r.lastIndexOf(s)!==e&&r.push(s),t),[]);if(t.length>0)throw new Error(`Duplicate ids found: ${t}`)}static createIdToIdxMap(t){const s={};return t.forEach(({id:t},e)=>s[t]=e),s}evaluateGraph(t,s){const e=s=>t[this.idToIdx[s]],r=this.constants.map(({value:t})=>t),a=t=>r[this.idToIdx[t]],o=t=>{const r=new Array(t.length);return{evaluator:o=>{const i=this.idToIdx[o];if(null===r[i])throw new Error("Evaluation cycle detected starting at: ${id}");return void 0===r[i]&&(r[i]=null,r[i]=t[i].equation(e,h,n,a,s)),r[i]},data:r}},{evaluator:n,data:i}=o(this.variables),{evaluator:h,data:c}=o(this.flows);return this.variables.forEach(({id:t})=>n(t)),this.flows.forEach(({id:t})=>h(t)),{stocks:t,flows:c,variables:i,constants:r,t:s}}step(t,s,e,r){return"number"==typeof s?this.step3(t,s,e):this.step4(t,s,e,r)}step3(t,s,e){return this.stepImpl(t,(t,s)=>this.evaluateGraph(t,s).flows,s,e)}step4(t,s,e,r){return this.stepImpl(t,(t,r)=>r===e?s:this.evaluateGraph(t,r).flows,e,r)}stepImpl(t,s,e,r){return this.integrator(t,e,r,(t,e)=>{const r=s(t,e),a=t=>r[this.idToIdx[t]],o=t=>t.map(a).reduce((t,s)=>t+s,0);return this.stocks.map(t=>o(t.in)-o(t.out))})}stepExt(t,s,e,r){return"number"==typeof s?this.stepExt3(t,s,e):this.stepExt4(t,s,e,r)}stepExt3(s,e,r){const a=this.step(s,e,r);return t({stocks:a},this.evaluateGraph(a,e+r))}stepExt4(s,e,r,a){const o=this.step(s,e,r,a);return t({stocks:o},this.evaluateGraph(o,r+a))}}export{r as BoxModel,s as euler,e as rk4};
//# sourceMappingURL=box-model.modern.js.map
