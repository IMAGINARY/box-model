function t(t,e,r,o){const s=o(t,e);return t.map((t,e)=>t+r*s[e])}function e(t,e,r,o){const s=t.length,a=o(t,e),n=new Array(s),l=r/2,i=r/6,c=e+l;for(let e=0;e<s;e+=1)n[e]=t[e]+l*a[e];let p=o(n,c);for(let e=0;e<s;e+=1)n[e]=t[e]+l*p[e];const h=o(n,c);for(let e=0;e<s;e+=1)n[e]=t[e]+r*h[e],h[e]+=p[e];return p=o(n,e+r),t.map((e,r)=>t[r]+i*(a[r]+p[r]+2*h[r]))}const r=Object.prototype.hasOwnProperty;function o(t,e){return r.call(t,e)}function s(t,e){throw new Error(`Value of unknown ${t} requested: ${e}. Check your box model definition.`)}class a{constructor(t,r={integrator:e}){this.model=void 0,this.integrator=void 0,this.model=t,this.integrator=r.integrator}static createIdToIdxMap(t){return t.reduce((t,{id:e},r)=>(t[e]=r,t),{})}createGraphEvaluator(){const{stocks:t,flows:e,variables:r,parameters:n}=this.model,l=a.createIdToIdxMap(t),i=a.createIdToIdxMap(e),c=a.createIdToIdxMap(r),p=a.createIdToIdxMap(n);let h={t:0,stocks:new Array(t.length),flows:new Array(e.length),variables:new Array(r.length),parameters:new Array(n.length)};const u=new Array(e.length),f=new Array(r.length),d=t=>(o(l,t)||s("stock",t),h.stocks[l[t]]),w=t=>(o(p,t)||s("parameter",t),h.parameters[p[t]]);let v;const m=t=>{o(i,t)||s("variable",t);const r=i[t];if(void 0===h.flows[r]){if(u[r])throw new Error(`Evaluation cycle detected starting at: flow ${t}`);u[r]=!0,h.flows[r]=e[r].formula({s:d,f:m,v,p:w,t:h.t})}return h.flows[r]};return v=t=>{o(c,t)||s("variable",t);const e=c[t];if(void 0===h.variables[e]){if(f[e])throw new Error(`Evaluation cycle detected starting at: variable ${t}`);f[e]=!0,h.variables[e]=r[e].formula({s:d,f:m,v,p:w,t:h.t})}return h.variables[e]},(t,o)=>(h={t:o,stocks:t,flows:new Array(e.length),variables:new Array(r.length),parameters:n.map(({value:t})=>t)},u.fill(!1),f.fill(!1),this.model.variables.forEach(({id:t})=>v(t)),this.model.flows.forEach(({id:t})=>m(t)),h)}evaluateGraph(t,e){return this.createGraphEvaluator()(t,e)}step(t,e,r,o){if("number"==typeof e)return this.step3(t,e,r);if(void 0!==o)return this.step4(t,e,r,o);throw new TypeError}step3(t,e,r){const o=this.createGraphEvaluator();return this.stepImpl(t,(t,e)=>o(t,e).flows,e,r)}step4(t,e,r,o){const s=this.createGraphEvaluator();return this.stepImpl(t,(t,o)=>o===r?e:s(t,o).flows,r,o)}stepImpl(t,e,r,o){const s=a.createIdToIdxMap(this.model.flows);return this.integrator(t,r,o,(t,r)=>{const o=e(t,r),a=t=>o[s[t]],n=t=>t.map(a).reduce((t,e)=>t+e,0);return this.model.stocks.map(t=>n(t.in)-n(t.out))})}stepExt(t,e,r,o){if("number"==typeof e)return this.stepExt3(t,e,r);if(void 0!==o)return this.stepExt4(t,e,r,o);throw new TypeError}stepExt3(t,e,r){const o=this.step(t,e,r);return this.evaluateGraph(o,e+r)}stepExt4(t,e,r,o){const s=this.step(t,e,r,o);return this.evaluateGraph(s,r+o)}converge(t,e,r,o){return this.convergeExt(t,e,r,o).stocks}convergeExt(t,e,r,o){const s=this.createGraphEvaluator();let a=s(t,e);const n=(t,e)=>e===a.t?a.flows:s(t,e).flows;for(let t=0,l=!1;!l;t+=1){const i=this.stepImpl(a.stocks,n,a.t,r),c=s(i,e+t*r);l=o(c,a,t,this),a=c}return a}}export{a as BoxModelEngine,t as euler,e as rk4};
//# sourceMappingURL=box-model.modern.js.map
